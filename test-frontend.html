<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ™ºè°±AIåŠŸèƒ½æµ‹è¯•</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        .test-section { margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 8px; }
        .success { background-color: #d4edda; border-color: #c3e6cb; }
        .error { background-color: #f8d7da; border-color: #f5c6cb; }
        button { padding: 10px 15px; margin: 5px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; }
        button:hover { background: #0056b3; }
        textarea { width: 100%; height: 100px; margin: 10px 0; }
        .result { margin: 10px 0; padding: 10px; background: #f8f9fa; border-radius: 4px; }
    </style>
</head>
<body>
    <h1>ğŸ§ª æ™ºè°±AIåŠŸèƒ½æµ‹è¯•é¡µé¢</h1>
    <p>APIå¯†é’¥: a75d46768b0f45dc90a5969077ffc8d9.dT0t2tku3hZGfYkk</p>
    
    <div class="test-section">
        <h3>ğŸ”¤ æ–‡æœ¬å¯¹è¯æµ‹è¯•</h3>
        <textarea id="chatInput" placeholder="è¾“å…¥æ‚¨çš„é—®é¢˜...">ä½ å¥½ï¼Œè¯·ä»‹ç»ä¸€ä¸‹æ™ºè°±AIçš„ä¸»è¦åŠŸèƒ½</textarea>
        <button onclick="testChat()">å‘é€æ¶ˆæ¯</button>
        <div id="chatResult" class="result"></div>
    </div>
    
    <div class="test-section">
        <h3>ğŸ”Š è¯­éŸ³åˆæˆæµ‹è¯•</h3>
        <textarea id="ttsInput" placeholder="è¾“å…¥è¦åˆæˆçš„æ–‡å­—...">æ‚¨å¥½ï¼Œè¿™æ˜¯æ™ºè°±AIè¯­éŸ³åˆæˆåŠŸèƒ½æµ‹è¯•</textarea>
        <select id="voiceSelect">
            <option value="tongtong">é€šé€š(å¥³å£°)</option>
            <option value="zhangsan">å¼ ä¸‰(ç”·å£°)</option>
            <option value="lisi">æå››(ç”·å£°)</option>
        </select>
        <button onclick="testTTS()">ç”Ÿæˆè¯­éŸ³</button>
        <button onclick="playAudio()" id="playBtn" disabled>æ’­æ”¾éŸ³é¢‘</button>
        <div id="ttsResult" class="result"></div>
    </div>
    
    <div class="test-section">
        <h3>ğŸ§  å‘é‡åµŒå…¥æµ‹è¯•</h3>
        <textarea id="embeddingInput" placeholder="è¾“å…¥è¦å‘é‡åŒ–çš„æ–‡æœ¬...">æ™ºèƒ½å®¢æœç³»ç»Ÿå¯ä»¥å¸®åŠ©ç”¨æˆ·è§£å†³å„ç§é—®é¢˜</textarea>
        <button onclick="testEmbedding()">ç”Ÿæˆå‘é‡</button>
        <div id="embeddingResult" class="result"></div>
    </div>
    
    <div class="test-section">
        <h3>ğŸ‘ï¸ å¤šæ¨¡æ€åˆ†ææµ‹è¯•</h3>
        <input type="file" id="imageInput" accept="image/*">
        <button onclick="testVision()">åˆ†æå›¾ç‰‡</button>
        <div id="visionResult" class="result"></div>
    </div>
    
    <div class="test-section">
        <h3>ğŸ“Š æµ‹è¯•ç»“æœæ±‡æ€»</h3>
        <div id="summary" class="result">
            <p>ç‚¹å‡»ä¸Šæ–¹æŒ‰é’®å¼€å§‹æµ‹è¯•å„é¡¹åŠŸèƒ½...</p>
        </div>
    </div>

    <script>
        const API_KEY = 'a75d46768b0f45dc90a5969077ffc8d9.dT0t2tku3hZGfYkk';
        const BASE_URL = 'https://open.bigmodel.cn/api/paas/v4';
        let audioData = null;
        let testResults = {
            chat: false,
            tts: false,
            embedding: false,
            vision: false
        };

        async function testChat() {
            const input = document.getElementById('chatInput').value;
            const resultDiv = document.getElementById('chatResult');
            resultDiv.innerHTML = 'ğŸ”„ æ­£åœ¨å¤„ç†...';
            
            try {
                const response = await fetch(`${BASE_URL}/chat/completions`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${API_KEY}`,
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        model: 'glm-4.7',
                        messages: [{ role: 'user', content: input }],
                        temperature: 0.1,
                        max_tokens: 200
                    })
                });
                
                const data = await response.json();
                if (response.ok) {
                    resultDiv.innerHTML = `âœ… <strong>å›å¤:</strong> ${data.choices[0].message.content}`;
                    resultDiv.className = 'result success';
                    testResults.chat = true;
                } else {
                    resultDiv.innerHTML = `âŒ <strong>é”™è¯¯:</strong> ${JSON.stringify(data)}`;
                    resultDiv.className = 'result error';
                }
            } catch (error) {
                resultDiv.innerHTML = `âŒ <strong>ç½‘ç»œé”™è¯¯:</strong> ${error.message}`;
                resultDiv.className = 'result error';
            }
            updateSummary();
        }

        async function testTTS() {
            const input = document.getElementById('ttsInput').value;
            const voice = document.getElementById('voiceSelect').value;
            const resultDiv = document.getElementById('ttsResult');
            resultDiv.innerHTML = 'ğŸ”„ æ­£åœ¨ç”Ÿæˆè¯­éŸ³...';
            
            try {
                const response = await fetch(`${BASE_URL}/audio/speech`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${API_KEY}`,
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        model: 'glm-tts',
                        input: input,
                        voice: voice,
                        response_format: 'wav'
                    })
                });
                
                if (response.ok) {
                    const arrayBuffer = await response.arrayBuffer();
                    const blob = new Blob([arrayBuffer], { type: 'audio/wav' });
                    audioData = URL.createObjectURL(blob);
                    
                    resultDiv.innerHTML = `âœ… <strong>è¯­éŸ³ç”ŸæˆæˆåŠŸ!</strong> éŸ³é¢‘å¤§å°: ${arrayBuffer.byteLength} bytes`;
                    resultDiv.className = 'result success';
                    document.getElementById('playBtn').disabled = false;
                    testResults.tts = true;
                } else {
                    const error = await response.json();
                    resultDiv.innerHTML = `âŒ <strong>é”™è¯¯:</strong> ${JSON.stringify(error)}`;
                    resultDiv.className = 'result error';
                }
            } catch (error) {
                resultDiv.innerHTML = `âŒ <strong>ç½‘ç»œé”™è¯¯:</strong> ${error.message}`;
                resultDiv.className = 'result error';
            }
            updateSummary();
        }

        function playAudio() {
            if (audioData) {
                const audio = new Audio(audioData);
                audio.play();
            }
        }

        async function testEmbedding() {
            const input = document.getElementById('embeddingInput').value;
            const resultDiv = document.getElementById('embeddingResult');
            resultDiv.innerHTML = 'ğŸ”„ æ­£åœ¨ç”Ÿæˆå‘é‡...';
            
            try {
                const response = await fetch(`${BASE_URL}/embeddings`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${API_KEY}`,
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        model: 'embedding-3',
                        input: [input],
                        dimensions: 768
                    })
                });
                
                const data = await response.json();
                if (response.ok) {
                    const vector = data.data[0].embedding;
                    resultDiv.innerHTML = `âœ… <strong>å‘é‡ç”ŸæˆæˆåŠŸ!</strong> ç»´åº¦: ${vector.length}, å‰5ä¸ªå€¼: [${vector.slice(0, 5).map(v => v.toFixed(4)).join(', ')}...]`;
                    resultDiv.className = 'result success';
                    testResults.embedding = true;
                } else {
                    resultDiv.innerHTML = `âŒ <strong>é”™è¯¯:</strong> ${JSON.stringify(data)}`;
                    resultDiv.className = 'result error';
                }
            } catch (error) {
                resultDiv.innerHTML = `âŒ <strong>ç½‘ç»œé”™è¯¯:</strong> ${error.message}`;
                resultDiv.className = 'result error';
            }
            updateSummary();
        }

        async function testVision() {
            const fileInput = document.getElementById('imageInput');
            const resultDiv = document.getElementById('visionResult');
            
            if (!fileInput.files[0]) {
                resultDiv.innerHTML = 'âŒ è¯·å…ˆé€‰æ‹©ä¸€å¼ å›¾ç‰‡';
                resultDiv.className = 'result error';
                return;
            }
            
            resultDiv.innerHTML = 'ğŸ”„ æ­£åœ¨åˆ†æå›¾ç‰‡...';
            
            try {
                const file = fileInput.files[0];
                const base64 = await fileToBase64(file);
                
                const response = await fetch(`${BASE_URL}/chat/completions`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${API_KEY}`,
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        model: 'glm-4.6v',
                        messages: [{
                            role: 'user',
                            content: [
                                { type: 'text', text: 'è¯·è¯¦ç»†æè¿°è¿™å¼ å›¾ç‰‡çš„å†…å®¹' },
                                { type: 'image_url', image_url: { url: base64 } }
                            ]
                        }],
                        temperature: 0.1,
                        max_tokens: 300
                    })
                });
                
                const data = await response.json();
                if (response.ok) {
                    resultDiv.innerHTML = `âœ… <strong>å›¾ç‰‡åˆ†æç»“æœ:</strong> ${data.choices[0].message.content}`;
                    resultDiv.className = 'result success';
                    testResults.vision = true;
                } else {
                    resultDiv.innerHTML = `âŒ <strong>é”™è¯¯:</strong> ${JSON.stringify(data)}`;
                    resultDiv.className = 'result error';
                }
            } catch (error) {
                resultDiv.innerHTML = `âŒ <strong>ç½‘ç»œé”™è¯¯:</strong> ${error.message}`;
                resultDiv.className = 'result error';
            }
            updateSummary();
        }

        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => resolve(reader.result);
                reader.onerror = error => reject(error);
            });
        }

        function updateSummary() {
            const successCount = Object.values(testResults).filter(Boolean).length;
            const totalCount = Object.keys(testResults).length;
            const summaryDiv = document.getElementById('summary');
            
            let html = `<h4>æµ‹è¯•è¿›åº¦: ${successCount}/${totalCount}</h4>`;
            html += `<p>æ–‡æœ¬å¯¹è¯: ${testResults.chat ? 'âœ…' : 'â³'}</p>`;
            html += `<p>è¯­éŸ³åˆæˆ: ${testResults.tts ? 'âœ…' : 'â³'}</p>`;
            html += `<p>å‘é‡åµŒå…¥: ${testResults.embedding ? 'âœ…' : 'â³'}</p>`;
            html += `<p>å¤šæ¨¡æ€åˆ†æ: ${testResults.vision ? 'âœ…' : 'â³'}</p>`;
            
            if (successCount === totalCount) {
                html += `<p style="color: green; font-weight: bold;">ğŸ‰ æ‰€æœ‰åŠŸèƒ½æµ‹è¯•é€šè¿‡ï¼</p>`;
                summaryDiv.className = 'result success';
            } else {
                summaryDiv.className = 'result';
            }
            
            summaryDiv.innerHTML = html;
        }
    </script>
</body>
</html>